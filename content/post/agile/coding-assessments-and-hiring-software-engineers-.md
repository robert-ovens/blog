---
title: "Code Assessments and Hiring Software Engineers"
date: 2017-09-11T19:22:01+10:00
draft: false
categories:
  - agile

---

If you're hiring software engineers, you're probably using a coding exam or assessment to understand the capability of a candidate. But a more complex exam does not necessarily do a better job of finding a more competent engineer. 

<!--more-->

## TL;DR;
* Keep it simple. The problem domain is merely a canvas for the engineer to demonstrate their ability to apply [SOLID] (https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) principles. 
* Keep it short. It's inconsiderate to expect someone to spend 10 - 15 hours cranking out a solution. 
* Keep the candidate informed. Let the candidate know what you are looking for in a coding assessment, and let them know what the steps in the hiring process will be.
* Use a pair programming session to extend the solution. Focus on problem solving and communication skills (verbal, non verbal and code). 


## Keep It Simple

Our coding assessment is very simple. It's command line program that involves a sorting task. It interacts with the file system and the console. In fact, a solution could be written with only a small amount of code. However the simplicity of the coding exam is the reason it has been so useful for us at GlobalX. It allows the candidate to focus on demonstrating what they perceive to be high quality code.

The coding assessment we send out introduces itself to the candidate with the following paragraph;

> The problem domain of the GlobalX coding assessment is deliberately simple, and you could very easily write an extremely terse solution that satisfies the requirement. But our goal is not to see you implement a trivial sorting algorithm. It is to understand if your code communicates it's purpose clearly and with empathy to your potential team members. What do we mean by empathy? Empathy here is caring about how easy your code is to understand and navigate for the next engineer who touches it. We also want to understand your ability to compose quality code that adheres to [SOLID] (https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) principles. Thirdly, to see how you write tests. Imagine this is one of many features your team will write, and this is the start of that codebase.

We keep a list of the criteria we are focussed on.

* Communication skills, written and verbal
* Problem solving 
* Pragmatic engineering
* Self confidence over brittle ego (no brilliant jerks. Some companies tolerate them. We don't.)

Keeping it simple allows the candidate to concentrate on their craft. If they have to spend 80% of their time familiarising themselves with an new API or business domain, then what you're really assessing how quickly they can assimilate information, rather than how they write high quality, maintainable code.


## Keep It Short

We keep the assessment short because ''you are not the only employer''. A candidate is most likely considering a number of employers. To assume that they want to spend an entire weekend building out your Twitter/data.gov.au/Yummly API mashup challenge is fairly assumptive to say the least. They may let your code assessment slide in favour of one that lets them hang out with their loved ones as well. Be nice :-)


## Keep the Candidate Informed

At all stages we explain the current and what it's purpose is. Really this is about demonstrating the empathy that you would expect in your engineers. Being ill informed sucks If the candidate is not selected to progress to the next stage, take the time to explain why. This is their opportunity for them to take the feedback into their approach to interviews and improve iteratively. 


## Pair Programming

For us the most important step is to conduct a pair programming session with the candidate. At GlobalX we typically will take the code they submitted as part of their code assessment and modify it in some way, or focus on an area of their solution that we have questions about. Using the candidate's code assessment solution is great because they are familiar with the problem domain as well as the code. Cognitive load is reduced and the candidate can focus on demonstrating their engineering skills, as well as their communication and teamwork skills.


## Consistency Can Build A Baseline For Comparison


We've been using the same coding assessment for three years and it's been a great normative guide for hiring engineers. We can compare an engineer's solution to our library of previous solutions for hiring guidance. 

## What Works For You?

This is all subjective of course. If you organisation relies on machine learning algorithms for example, the selection criteria you are focussing will likely be different to ours. What kind of problem are you setting for in the coding assessment you give to candidates? I'd be interested to know :-)

